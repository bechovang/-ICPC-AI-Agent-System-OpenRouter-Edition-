{
    "title": "Graph Traversal (BFS & DFS)",
    "aliases": ["Breadth-First Search", "Depth-First Search", "Graph Search"],
    "categories": ["graph", "graph_traversal", "searching"],
    "summary": "The two primary algorithms for visiting all nodes and edges in a graph. BFS explores level by level and finds the shortest path in unweighted graphs. DFS explores as deeply as possible along each branch before backtracking and is useful for pathfinding, cycle detection, and topology.",
    "prerequisites": ["Graph Theory", "Adjacency List", "Queue", "Stack/Recursion"],
    "complexity": {
      "time": "O(V + E)",
      "space": "O(V)"
    },
    "theory": "BFS uses a queue to explore nodes layer by layer, guaranteeing that the first time a node is reached, it is via the shortest path in terms of number of edges. DFS uses a stack (or recursion) to go as deep as possible down one path before exploring siblings. A `visited` array is crucial for both to avoid infinite loops and re-processing nodes.",
    "implementations": [
      {
        "name": "BFS for Shortest Path (Unweighted)",
        "language": "cpp",
        "code": "#include <vector>\n#include <queue>\n\nconst int UNVISITED = -1;\n\nvoid bfs(int start, int n, const std::vector<std::vector<int>>& adj, std::vector<int>& dist) {\n    dist.assign(n + 1, UNVISITED);\n    std::queue<int> q;\n\n    dist[start] = 0;\n    q.push(start);\n\n    while (!q.empty()) {\n        int u = q.front(); q.pop();\n        for (int v : adj[u]) {\n            if (dist[v] == UNVISITED) {\n                dist[v] = dist[u] + 1;\n                q.push(v);\n            }\n        }\n    }\n}"
      },
      {
        "name": "DFS for Connectivity and Path Finding",
        "language": "cpp",
        "code": "#include <vector>\n\nvoid dfs(int u, const std::vector<std::vector<int>>& adj, std::vector<bool>& visited) {\n    visited[u] = true;\n    // Process node u\n    for (int v : adj[u]) {\n        if (!visited[v]) {\n            dfs(v, adj, visited);\n        }\n    }\n}"
      }
    ],
    "common_pitfalls": [
      "Forgetting to mark a node as visited *immediately* after pushing it to the queue in BFS, which can lead to the same node being added multiple times.",
      "Using BFS for weighted shortest path problems (Dijkstra's is needed).",
      "Potential for stack overflow in DFS on very deep graphs or long paths if using recursion (an iterative approach with an explicit stack can help)."
    ],
    "example_problems": [
      {
        "id": "CSES Message Route",
        "link": "https://cses.fi/problemset/task/1667",
        "description": "Given a computer network, find the shortest route (minimum number of computers) between two given computers. This is a classic shortest path problem on an unweighted graph, making BFS the perfect algorithm. The solution also requires reconstructing the path.",
        "tags": ["bfs", "shortest_path", "unweighted_graph", "path_reconstruction"],
        "variation": "BFS with path reconstruction"
      },
      {
        "id": "CSES Building Teams",
        "link": "https://cses.fi/problemset/task/1668",
        "description": "Assign every pupil to one of two teams, such that no two pupils in the same team have a friendship. This is equivalent to checking if the graph is bipartite (2-colorable). This can be solved using either BFS or DFS to traverse the graph and assign alternating colors (teams) to adjacent nodes. If we ever find an edge connecting two nodes of the same color, it's impossible.",
        "tags": ["dfs", "bfs", "bipartite_graph", "2-coloring", "connectivity"],
        "variation": "Graph coloring"
      }
    ]
  }