{
    "title": "STL Map and Set Usage",
    "aliases": ["std::map", "std::set", "Frequency Counting", "Associative Containers", "std::unordered_map"],
    "categories": ["stl", "data_structure", "technique"],
    "summary": "Essential C++ STL containers for managing collections of objects. `std::map` stores key-value pairs and is ideal for frequency counting. `std::set` stores unique, sorted elements and is perfect for checking existence or eliminating duplicates. Their `unordered_` counterparts offer faster average performance.",
    "prerequisites": ["STL", "Key-Value Pairs"],
    "complexity": {
      "map/set_operations": "O(log N)",
      "unordered_map/set_operations": "O(1) on average, O(N) worst-case",
      "space": "O(N)"
    },
    "theory": "`std::map` (implemented as a Red-Black Tree) stores elements sorted by key. `std::unordered_map` (implemented as a Hash Table) offers faster average access but does not maintain order. `std::set` is similar to `map` but only stores unique keys. Use the ordered versions when you need to iterate in sorted order or find bounds (e.g., `lower_bound`). Use the unordered versions for maximum speed when order is not important.",
    "implementations": [
      {
        "name": "Frequency Counting with std::map",
        "language": "cpp",
        "code": "#include <iostream>\n#include <vector>\n#include <map>\n\nvoid countFrequencies() {\n    std::vector<int> nums = {1, 2, 2, 3, 1, 2, 4};\n    std::map<int, int> freq;\n    for (int x : nums) {\n        freq[x]++;\n    }\n    // freq will be {{1, 2}, {2, 3}, {3, 1}, {4, 1}}\n    for (auto const& [key, val] : freq) {\n        std::cout << key << \": \" << val << std::endl;\n    }\n}"
      },
      {
        "name": "Managing Unique Elements with std::set",
        "language": "cpp",
        "code": "#include <iostream>\n#include <vector>\n#include <set>\n\nvoid findUnique() {\n    std::vector<int> nums = {10, 20, 10, 30, 20};\n    std::set<int> unique_elements;\n    for (int x : nums) {\n        unique_elements.insert(x);\n    }\n    // unique_elements will contain {10, 20, 30}\n    std::cout << \"Number of unique elements: \" << unique_elements.size() << std::endl;\n}"
      }
    ],
    "common_pitfalls": [
      "Using `map` or `set` when `unordered_map` or `unordered_set` would be faster and sufficient. The log factor can matter in tight time limits.",
      "Being unaware of the potential O(N) worst-case performance of unordered containers, which can be exploited by carefully crafted test data (anti-hash tests).",
      "Iterating and modifying a map/set simultaneously in a way that invalidates iterators."
    ],
    "example_problems": [
      {
        "id": "CSES Distinct Numbers",
        "link": "https://cses.fi/problemset/task/1621",
        "description": "Given a list of numbers, your task is to count the number of distinct values. This is the canonical problem for `std::set`. Simply insert all numbers from the input list into a set, and the final size of the set is the answer.",
        "tags": ["set", "counting", "distinct_elements"],
        "variation": "Direct application of set property"
      },
      {
        "id": "Kattis Trik",
        "link": "https://open.kattis.com/problems/trik",
        "description": "A simple simulation problem where you track the position of a ball under one of three cups. While it can be solved with if-statements, using a `std::map<char, int>` to map swap characters ('A', 'B', 'C') to cup indices (0, 1, 2) can make the code cleaner and more extensible, although it's overkill for this specific problem, it demonstrates a common pattern.",
        "tags": ["map", "simulation", "ad_hoc"],
        "variation": "Using map for state transition"
      }
    ]
  }