{
    "title": "Prefix Sums and Difference Arrays",
    "aliases": ["Prefix Sum Array", "PSA", "Difference Array"],
    "categories": ["technique", "range_query", "optimization"],
    "summary": "A powerful technique to answer range sum queries in O(1) time after an O(N) preprocessing. The complementary concept, Difference Arrays, allows for O(1) range updates, with the final values retrievable in O(N).",
    "prerequisites": ["Arrays"],
    "complexity": {
      "prefix_sum_build": "O(N)",
      "prefix_sum_query": "O(1)",
      "diff_array_update": "O(1)",
      "diff_array_build": "O(N)"
    },
    "theory": "A Prefix Sum Array `P` is defined as `P[i] = A[0] + ... + A[i]`. The sum of a range `[L, R]` can then be calculated as `P[R] - P[L-1]`. A Difference Array `D` is defined as `D[i] = A[i] - A[i-1]`. To add a value `val` to a range `[L, R]` in the original array, we only need to perform two operations on the difference array: `D[L] += val` and `D[R+1] -= val`. The original array can be reconstructed from the difference array by taking its prefix sums.",
    "implementations": [
      {
        "name": "Prefix Sum Array for Range Sums",
        "language": "cpp",
        "code": "#include <vector>\n\n// Using 1-based indexing for simplicity\nvoid build_prefix_sum(const std::vector<int>& a, std::vector<long long>& p, int n) {\n    p.assign(n + 1, 0);\n    for (int i = 1; i <= n; ++i) {\n        p[i] = p[i - 1] + a[i - 1]; // Assuming 'a' is 0-indexed\n    }\n}\n\nlong long query_sum(const std::vector<long long>& p, int l, int r) {\n    // Get sum of range [l, r] (1-based)\n    return p[r] - p[l - 1];\n}"
      },
      {
        "name": "Difference Array for Range Updates",
        "language": "cpp",
        "code": "#include <vector>\n\n// Apply updates to difference array d (1-based)\nvoid range_update(std::vector<int>& d, int l, int r, int val) {\n    d[l] += val;\n    if (r + 1 < d.size()) {\n        d[r + 1] -= val;\n    }\n}\n\n// Reconstruct original array from difference array\nvoid reconstruct_array(std::vector<int>& a, std::vector<int>& d, int n) {\n    a.assign(n + 1, 0);\n    a[1] = d[1];\n    for (int i = 2; i <= n; ++i) {\n        a[i] = a[i - 1] + d[i];\n    }\n}"
      }
    ],
    "common_pitfalls": [
      "Off-by-one errors, especially with 0-based vs 1-based indexing. `query(l, r)` is `p[r] - p[l-1]` for 1-based indexing.",
      "Forgetting to subtract from `D[R+1]` in difference arrays, or accessing an out-of-bounds index if `R` is the last element.",
      "Integer overflow when calculating prefix sums; the prefix sum array should often be `long long`."
    ],
    "example_problems": [
      {
        "id": "CSES Static Range Sum Queries",
        "link": "https://cses.fi/problemset/task/1646",
        "description": "Given a static array, answer multiple queries asking for the sum of elements in a given range. This is the textbook application of a Prefix Sum Array. Precompute the prefix sums in O(N) and answer each of the Q queries in O(1).",
        "tags": ["prefix_sum", "range_query", "static_array"],
        "variation": "Direct application"
      },
      {
        "id": "CSES Dynamic Range Sum Queries (Partial Solution)",
        "link": "https://cses.fi/problemset/task/1648",
        "description": "If a problem involves many range *updates* but only requires the final state of the array (not queries in-between updates), a Difference Array is ideal. Apply all updates in O(Q) total, then reconstruct the final array in O(N). This problem actually requires a Fenwick Tree for full credit, but the Difference Array approach is a key concept.",
        "tags": ["difference_array", "range_update", "offline_processing"],
        "variation": "Range updates, final state queries"
      }
    ]
  }